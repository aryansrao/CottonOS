//! Framebuffer Graphics Driver
//! 
//! Provides pixel-based drawing for GUI with double buffering

use spin::Mutex;
use alloc::vec::Vec;

/// RGB Color with alpha support
#[derive(Clone, Copy, PartialEq)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

impl Color {
    pub const fn rgb(r: u8, g: u8, b: u8) -> Self {
        Self { r, g, b, a: 255 }
    }
    
    pub const fn rgba(r: u8, g: u8, b: u8, a: u8) -> Self {
        Self { r, g, b, a }
    }
    
    /// Blend two colors (self over other)
    pub fn blend(&self, other: Color) -> Color {
        if self.a == 255 { return *self; }
        if self.a == 0 { return other; }
        
        let alpha = self.a as u32;
        let inv_alpha = 255 - alpha;
        
        Color::rgb(
            ((self.r as u32 * alpha + other.r as u32 * inv_alpha) / 255) as u8,
            ((self.g as u32 * alpha + other.g as u32 * inv_alpha) / 255) as u8,
            ((self.b as u32 * alpha + other.b as u32 * inv_alpha) / 255) as u8,
        )
    }
    
    pub const BLACK: Color = Color::rgb(0, 0, 0);
    pub const WHITE: Color = Color::rgb(255, 255, 255);
    pub const RED: Color = Color::rgb(255, 59, 48);
    pub const GREEN: Color = Color::rgb(52, 199, 89);
    pub const BLUE: Color = Color::rgb(0, 122, 255);
    pub const CYAN: Color = Color::rgb(0, 255, 255);
    pub const MAGENTA: Color = Color::rgb(255, 0, 255);
    pub const YELLOW: Color = Color::rgb(255, 204, 0);
    pub const ORANGE: Color = Color::rgb(255, 149, 0);
    pub const GRAY: Color = Color::rgb(128, 128, 128);
    pub const DARK_GRAY: Color = Color::rgb(44, 44, 46);
    pub const LIGHT_GRAY: Color = Color::rgb(174, 174, 178);
    
    // Modern dark theme colors
    pub const DESKTOP_BG: Color = Color::rgb(0, 0, 0);            // Pure black
    pub const WINDOW_BG: Color = Color::rgb(44, 44, 46);          // Dark gray
    pub const WINDOW_BG_LIGHT: Color = Color::rgb(58, 58, 60);    // Slightly lighter
    pub const TITLE_BAR: Color = Color::rgb(38, 38, 40);          // Dark title
    pub const TITLE_BAR_INACTIVE: Color = Color::rgb(50, 50, 52);
    pub const TEXT_PRIMARY: Color = Color::rgb(255, 255, 255);
    pub const TEXT_SECONDARY: Color = Color::rgb(152, 152, 157);
    pub const ACCENT: Color = Color::rgb(10, 132, 255);           // Blue accent
    pub const BUTTON_BG: Color = Color::rgb(72, 72, 74);
    pub const BUTTON_HOVER: Color = Color::rgb(99, 99, 102);
    pub const BORDER: Color = Color::rgb(68, 68, 70);

    // Window button colors (macOS style)
    pub const CLOSE_BTN: Color = Color::rgb(255, 95, 87);
    pub const MINIMIZE_BTN: Color = Color::rgb(255, 189, 46);
    pub const MAXIMIZE_BTN: Color = Color::rgb(39, 201, 63);
}

/// Back buffer for double buffering
pub static BACK_BUFFER: Mutex<Vec<u32>> = Mutex::new(Vec::new());
/// Back buffer dimensions
pub static BB_WIDTH: Mutex<u32> = Mutex::new(0);
pub static BB_HEIGHT: Mutex<u32> = Mutex::new(0);

/// Framebuffer info
pub struct Framebuffer {
    pub address: u64,
    pub width: u32,
    pub height: u32,
    pub pitch: u32,
    pub bpp: u8,
    pub red_shift: u8,
    pub green_shift: u8,
    pub blue_shift: u8,
}

impl Framebuffer {
    pub const fn new() -> Self {
        Self {
            address: 0,
            width: 0,
            height: 0,
            pitch: 0,
            bpp: 0,
            red_shift: 16,
            green_shift: 8,
            blue_shift: 0,
        }
    }
    
    /// Set pixel at (x, y)
    pub fn set_pixel(&self, x: u32, y: u32, color: Color) {
        if x >= self.width || y >= self.height || self.address == 0 {
            return;
        }
        
        let pixel_offset = (y * self.pitch + x * (self.bpp as u32 / 8)) as usize;
        let pixel_addr = (self.address as usize + pixel_offset) as *mut u32;
        
        let pixel_value = ((color.r as u32) << self.red_shift)
            | ((color.g as u32) << self.green_shift)
            | ((color.b as u32) << self.blue_shift);
        
        unsafe {
            core::ptr::write_volatile(pixel_addr, pixel_value);
        }
    }
    
    /// Fill rectangle
    pub fn fill_rect(&self, x: u32, y: u32, w: u32, h: u32, color: Color) {
        for dy in 0..h {
            for dx in 0..w {
                self.set_pixel(x + dx, y + dy, color);
            }
        }
    }
    
    /// Draw rectangle outline
    pub fn draw_rect(&self, x: u32, y: u32, w: u32, h: u32, color: Color) {
        // Top and bottom
        for dx in 0..w {
            self.set_pixel(x + dx, y, color);
            self.set_pixel(x + dx, y + h - 1, color);
        }
        // Left and right
        for dy in 0..h {
            self.set_pixel(x, y + dy, color);
            self.set_pixel(x + w - 1, y + dy, color);
        }
    }
    
    /// Draw 3D-style border (raised)
    pub fn draw_raised_rect(&self, x: u32, y: u32, w: u32, h: u32) {
        // Top-left highlight
        for dx in 0..w {
            self.set_pixel(x + dx, y, Color::WHITE);
        }
        for dy in 0..h {
            self.set_pixel(x, y + dy, Color::WHITE);
        }
        // Bottom-right shadow
        for dx in 0..w {
            self.set_pixel(x + dx, y + h - 1, Color::DARK_GRAY);
        }
        for dy in 0..h {
            self.set_pixel(x + w - 1, y + dy, Color::DARK_GRAY);
        }
    }
    
    /// Draw 3D-style border (sunken)
    pub fn draw_sunken_rect(&self, x: u32, y: u32, w: u32, h: u32) {
        // Top-left shadow
        for dx in 0..w {
            self.set_pixel(x + dx, y, Color::DARK_GRAY);
        }
        for dy in 0..h {
            self.set_pixel(x, y + dy, Color::DARK_GRAY);
        }
        // Bottom-right highlight
        for dx in 0..w {
            self.set_pixel(x + dx, y + h - 1, Color::WHITE);
        }
        for dy in 0..h {
            self.set_pixel(x + w - 1, y + dy, Color::WHITE);
        }
    }
    
    /// Clear screen
    pub fn clear(&self, color: Color) {
        self.fill_rect(0, 0, self.width, self.height, color);
    }
    
    /// Draw character (8x16 bitmap font)
    pub fn draw_char(&self, x: u32, y: u32, c: char, fg: Color, bg: Option<Color>) {
        let bitmap = get_char_bitmap(c);
        for row in 0..16 {
            let bits = bitmap[row];
            for col in 0..8 {
                if (bits >> (7 - col)) & 1 == 1 {
                    self.set_pixel(x + col, y + row as u32, fg);
                } else if let Some(bg_color) = bg {
                    self.set_pixel(x + col, y + row as u32, bg_color);
                }
            }
        }
    }
    
    /// Draw string
    pub fn draw_string(&self, x: u32, y: u32, s: &str, fg: Color, bg: Option<Color>) {
        let mut cx = x;
        for c in s.chars() {
            if cx + 8 > self.width {
                break;
            }
            self.draw_char(cx, y, c, fg, bg);
            cx += 8;
        }
    }
    
    /// Draw horizontal line
    pub fn draw_hline(&self, x: u32, y: u32, len: u32, color: Color) {
        for dx in 0..len {
            self.set_pixel(x + dx, y, color);
        }
    }
    
    /// Draw vertical line
    pub fn draw_vline(&self, x: u32, y: u32, len: u32, color: Color) {
        for dy in 0..len {
            self.set_pixel(x, y + dy, color);
        }
    }
}

/// Global framebuffer
pub static FRAMEBUFFER: Mutex<Framebuffer> = Mutex::new(Framebuffer::new());

/// Initialize framebuffer
pub fn init(addr: u64, width: u32, height: u32, pitch: u32, bpp: u8) {
    let mut fb = FRAMEBUFFER.lock();
    fb.address = addr;
    fb.width = width;
    fb.height = height;
    fb.pitch = pitch;
    fb.bpp = bpp;
    // Assume standard RGB ordering
    fb.red_shift = 16;
    fb.green_shift = 8;
    fb.blue_shift = 0;
    
    crate::kprintln!("[GFX] Framebuffer initialized: {}x{} @ {:#x}", width, height, addr);
}

/// Check if graphics mode is available
pub fn is_available() -> bool {
    let fb = FRAMEBUFFER.lock();
    fb.address != 0 && fb.width > 0 && fb.height > 0
}

/// Simple 8x16 bitmap font - basic ASCII characters
fn get_char_bitmap(c: char) -> [u8; 16] {
    match c {
        'A' => [0x00, 0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'B' => [0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'C' => [0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'D' => [0x00, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'E' => [0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'F' => [0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'G' => [0x00, 0x3C, 0x66, 0x60, 0x60, 0x6E, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'H' => [0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'I' => [0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'J' => [0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'K' => [0x00, 0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'L' => [0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'M' => [0x00, 0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'N' => [0x00, 0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'O' => [0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'P' => [0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'Q' => [0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'R' => [0x00, 0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'S' => [0x00, 0x3C, 0x66, 0x60, 0x3C, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'T' => [0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'U' => [0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'V' => [0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'W' => [0x00, 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'X' => [0x00, 0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'Y' => [0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'Z' => [0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'a' => [0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'b' => [0x00, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'c' => [0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'd' => [0x00, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'e' => [0x00, 0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x60, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'f' => [0x00, 0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'g' => [0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'h' => [0x00, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'i' => [0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'j' => [0x00, 0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'k' => [0x00, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'l' => [0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'm' => [0x00, 0x00, 0x00, 0x76, 0x7F, 0x6B, 0x6B, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'n' => [0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'o' => [0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'p' => [0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'q' => [0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'r' => [0x00, 0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        's' => [0x00, 0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x06, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        't' => [0x00, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'u' => [0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'v' => [0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'w' => [0x00, 0x00, 0x00, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'x' => [0x00, 0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'y' => [0x00, 0x00, 0x00, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        'z' => [0x00, 0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '0' => [0x00, 0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '1' => [0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '2' => [0x00, 0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '3' => [0x00, 0x3C, 0x66, 0x06, 0x1C, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '4' => [0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '5' => [0x00, 0x7E, 0x60, 0x7C, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '6' => [0x00, 0x3C, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '7' => [0x00, 0x7E, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '8' => [0x00, 0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '9' => [0x00, 0x3C, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ' ' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '.' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ',' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ':' => [0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '!' => [0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '?' => [0x00, 0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '-' => [0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '_' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '/' => [0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '(' => [0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ')' => [0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '[' => [0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ']' => [0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '=' => [0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '+' => [0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '*' => [0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '<' => [0x00, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '>' => [0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        // Additional special characters
        '@' => [0x00, 0x3C, 0x66, 0x6E, 0x6E, 0x6E, 0x60, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '#' => [0x00, 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '$' => [0x00, 0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '%' => [0x00, 0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '^' => [0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '&' => [0x00, 0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '{' => [0x00, 0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '}' => [0x00, 0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '|' => [0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '\\' => [0x00, 0x40, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ';' => [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '\'' => [0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '"' => [0x00, 0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '~' => [0x00, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '`' => [0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        _ => [0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // Unknown char = filled box
    }
}

/// Initialize back buffer for double buffering
pub fn init_back_buffer(width: u32, height: u32) {
    let size = (width * height) as usize;
    let mut buffer = BACK_BUFFER.lock();
    *buffer = alloc::vec![0u32; size];
    *BB_WIDTH.lock() = width;
    *BB_HEIGHT.lock() = height;
    crate::kprintln!("[GFX] Back buffer initialized: {}x{} ({} bytes)", width, height, size * 4);
}

/// BackBuffer - same API as Framebuffer but draws to memory buffer
pub struct BackBuffer {
    pub width: u32,
    pub height: u32,
    pub red_shift: u8,
    pub green_shift: u8,
    pub blue_shift: u8,
}

impl BackBuffer {
    pub fn new() -> Self {
        let fb = FRAMEBUFFER.lock();
        Self {
            width: fb.width,
            height: fb.height,
            red_shift: fb.red_shift,
            green_shift: fb.green_shift,
            blue_shift: fb.blue_shift,
        }
    }
    
    /// Set pixel in back buffer
    pub fn set_pixel(&self, x: u32, y: u32, color: Color) {
        if x >= self.width || y >= self.height { return; }
        let mut buffer = BACK_BUFFER.lock();
        let idx = (y * self.width + x) as usize;
        if idx < buffer.len() {
            buffer[idx] = ((color.r as u32) << self.red_shift)
                | ((color.g as u32) << self.green_shift)
                | ((color.b as u32) << self.blue_shift);
        }
    }
    
    /// Fill rectangle in back buffer
    pub fn fill_rect(&self, x: u32, y: u32, w: u32, h: u32, color: Color) {
        let pixel_value = ((color.r as u32) << self.red_shift)
            | ((color.g as u32) << self.green_shift)
            | ((color.b as u32) << self.blue_shift);
        
        let mut buffer = BACK_BUFFER.lock();
        for dy in 0..h {
            let py = y + dy;
            if py >= self.height { break; }
            for dx in 0..w {
                let px = x + dx;
                if px >= self.width { break; }
                let idx = (py * self.width + px) as usize;
                if idx < buffer.len() {
                    buffer[idx] = pixel_value;
                }
            }
        }
    }
    
    /// Draw rectangle outline
    pub fn draw_rect(&self, x: u32, y: u32, w: u32, h: u32, color: Color) {
        for dx in 0..w {
            self.set_pixel(x + dx, y, color);
            self.set_pixel(x + dx, y + h - 1, color);
        }
        for dy in 0..h {
            self.set_pixel(x, y + dy, color);
            self.set_pixel(x + w - 1, y + dy, color);
        }
    }
    
    /// Draw raised 3D border
    pub fn draw_raised_rect(&self, x: u32, y: u32, w: u32, h: u32) {
        for dx in 0..w {
            self.set_pixel(x + dx, y, Color::WHITE);
        }
        for dy in 0..h {
            self.set_pixel(x, y + dy, Color::WHITE);
        }
        for dx in 0..w {
            self.set_pixel(x + dx, y + h - 1, Color::DARK_GRAY);
        }
        for dy in 0..h {
            self.set_pixel(x + w - 1, y + dy, Color::DARK_GRAY);
        }
    }
    
    /// Draw sunken 3D border
    pub fn draw_sunken_rect(&self, x: u32, y: u32, w: u32, h: u32) {
        for dx in 0..w {
            self.set_pixel(x + dx, y, Color::DARK_GRAY);
        }
        for dy in 0..h {
            self.set_pixel(x, y + dy, Color::DARK_GRAY);
        }
        for dx in 0..w {
            self.set_pixel(x + dx, y + h - 1, Color::WHITE);
        }
        for dy in 0..h {
            self.set_pixel(x + w - 1, y + dy, Color::WHITE);
        }
    }
    
    /// Clear entire back buffer
    pub fn clear(&self, color: Color) {
        let pixel_value = ((color.r as u32) << self.red_shift)
            | ((color.g as u32) << self.green_shift)
            | ((color.b as u32) << self.blue_shift);
        let mut buffer = BACK_BUFFER.lock();
        for pixel in buffer.iter_mut() {
            *pixel = pixel_value;
        }
    }
    
    /// Draw character
    pub fn draw_char(&self, x: u32, y: u32, c: char, fg: Color, bg: Option<Color>) {
        let bitmap = get_char_bitmap(c);
        for row in 0..16 {
            let bits = bitmap[row];
            for col in 0..8 {
                if (bits >> (7 - col)) & 1 == 1 {
                    self.set_pixel(x + col, y + row as u32, fg);
                } else if let Some(bg_color) = bg {
                    self.set_pixel(x + col, y + row as u32, bg_color);
                }
            }
        }
    }
    
    /// Draw string
    pub fn draw_string(&self, x: u32, y: u32, s: &str, fg: Color, bg: Option<Color>) {
        let mut cx = x;
        for c in s.chars() {
            if cx + 8 > self.width { break; }
            self.draw_char(cx, y, c, fg, bg);
            cx += 8;
        }
    }
    
    /// Draw horizontal line
    pub fn draw_hline(&self, x: u32, y: u32, len: u32, color: Color) {
        for dx in 0..len {
            self.set_pixel(x + dx, y, color);
        }
    }

    /// Draw vertical line  
    pub fn draw_vline(&self, x: u32, y: u32, len: u32, color: Color) {
        for dy in 0..len {
            self.set_pixel(x, y + dy, color);
        }
    }
    
    /// Draw a filled circle
    pub fn fill_circle(&self, cx: u32, cy: u32, r: u32, color: Color) {
        let r_sq = (r * r) as i32;
        for dy in 0..=r*2 {
            for dx in 0..=r*2 {
                let px = dx as i32 - r as i32;
                let py = dy as i32 - r as i32;
                if px*px + py*py <= r_sq {
                    let x = (cx as i32 + px) as u32;
                    let y = (cy as i32 + py) as u32;
                    self.set_pixel(x, y, color);
                }
            }
        }
    }
    
    /// Draw a filled rounded rectangle
    pub fn fill_rounded_rect(&self, x: u32, y: u32, w: u32, h: u32, radius: u32, color: Color) {
        let r = radius.min(w / 2).min(h / 2);
        
        // Fill main body (excluding corners)
        self.fill_rect(x + r, y, w - 2 * r, h, color);
        self.fill_rect(x, y + r, r, h - 2 * r, color);
        self.fill_rect(x + w - r, y + r, r, h - 2 * r, color);
        
        // Draw corners
        let r_sq = (r * r) as i32;
        for dy in 0..r {
            for dx in 0..r {
                let px = r as i32 - dx as i32 - 1;
                let py = r as i32 - dy as i32 - 1;
                if px*px + py*py <= r_sq {
                    // Top-left
                    self.set_pixel(x + dx, y + dy, color);
                    // Top-right
                    self.set_pixel(x + w - 1 - dx, y + dy, color);
                    // Bottom-left
                    self.set_pixel(x + dx, y + h - 1 - dy, color);
                    // Bottom-right
                    self.set_pixel(x + w - 1 - dx, y + h - 1 - dy, color);
                }
            }
        }
    }
    
    /// Draw rounded rectangle outline
    pub fn draw_rounded_rect(&self, x: u32, y: u32, w: u32, h: u32, radius: u32, color: Color) {
        let r = radius.min(w / 2).min(h / 2);
        
        // Top and bottom edges
        self.draw_hline(x + r, y, w - 2 * r, color);
        self.draw_hline(x + r, y + h - 1, w - 2 * r, color);
        
        // Left and right edges
        self.draw_vline(x, y + r, h - 2 * r, color);
        self.draw_vline(x + w - 1, y + r, h - 2 * r, color);
        
        // Draw corner arcs
        let r_sq = (r * r) as i32;
        let r_inner_sq = ((r - 1) * (r - 1)) as i32;
        for dy in 0..r {
            for dx in 0..r {
                let px = r as i32 - dx as i32 - 1;
                let py = r as i32 - dy as i32 - 1;
                let dist = px*px + py*py;
                if dist <= r_sq && dist >= r_inner_sq {
                    self.set_pixel(x + dx, y + dy, color);
                    self.set_pixel(x + w - 1 - dx, y + dy, color);
                    self.set_pixel(x + dx, y + h - 1 - dy, color);
                    self.set_pixel(x + w - 1 - dx, y + h - 1 - dy, color);
                }
            }
        }
    }
    
    
    /// Set pixel with alpha blending
    pub fn set_pixel_alpha(&self, x: u32, y: u32, color: Color) {
        if x >= self.width || y >= self.height || color.a == 0 { return; }
        
        let mut buffer = BACK_BUFFER.lock();
        let idx = (y * self.width + x) as usize;
        if idx >= buffer.len() { return; }
        
        if color.a == 255 {
            buffer[idx] = ((color.r as u32) << self.red_shift)
                | ((color.g as u32) << self.green_shift)
                | ((color.b as u32) << self.blue_shift);
        } else {
            // Read existing pixel and blend
            let existing = buffer[idx];
            let old_r = ((existing >> self.red_shift) & 0xFF) as u8;
            let old_g = ((existing >> self.green_shift) & 0xFF) as u8;
            let old_b = ((existing >> self.blue_shift) & 0xFF) as u8;
            
            let blended = color.blend(Color::rgb(old_r, old_g, old_b));
            buffer[idx] = ((blended.r as u32) << self.red_shift)
                | ((blended.g as u32) << self.green_shift)
                | ((blended.b as u32) << self.blue_shift);
        }
    }
    
    /// Fill rectangle with alpha blending
    pub fn fill_rect_alpha(&self, x: u32, y: u32, w: u32, h: u32, color: Color) {
        for dy in 0..h {
            for dx in 0..w {
                self.set_pixel_alpha(x + dx, y + dy, color);
            }
        }
    }
    
    /// Draw a gradient rectangle (vertical)
    pub fn fill_gradient_v(&self, x: u32, y: u32, w: u32, h: u32, top: Color, bottom: Color) {
        for dy in 0..h {
            let t = dy as f32 / h as f32;
            let r = (top.r as f32 * (1.0 - t) + bottom.r as f32 * t) as u8;
            let g = (top.g as f32 * (1.0 - t) + bottom.g as f32 * t) as u8;
            let b = (top.b as f32 * (1.0 - t) + bottom.b as f32 * t) as u8;
            self.fill_rect(x, y + dy, w, 1, Color::rgb(r, g, b));
        }
    }
}

/// Copy back buffer to framebuffer (the swap)
pub fn swap_buffers() {
    let fb = FRAMEBUFFER.lock();
    let buffer = BACK_BUFFER.lock();
    let width = *BB_WIDTH.lock();
    let height = *BB_HEIGHT.lock();
    
    if fb.address == 0 || buffer.is_empty() { return; }
    
    let bytes_per_pixel = (fb.bpp as u32 / 8) as usize;
    
    // Copy row by row to handle pitch
    for y in 0..height {
        let src_offset = (y * width) as usize;
        let dst_offset = (y * fb.pitch) as usize;
        let row_bytes = (width as usize) * bytes_per_pixel;
        
        unsafe {
            let src = buffer.as_ptr().add(src_offset) as *const u8;
            let dst = (fb.address as usize + dst_offset) as *mut u8;
            core::ptr::copy_nonoverlapping(src, dst, row_bytes);
        }
    }
}
